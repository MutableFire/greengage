-- Faster FTS probes
-- Let FTS detect/declare failure sooner
!\retcode gpconfig -c gp_fts_probe_interval -v 10 --masteronly;
(exited with code 0)
!\retcode gpconfig -c gp_fts_probe_retries -v 2 --masteronly;
(exited with code 0)
!\retcode gpconfig -c statement_timeout -v 2min;
(exited with code 0)
!\retcode gpconfig -c gp_fts_maintenance -v on --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

include: helpers/server_helpers.sql;
CREATE

-- Helper function
CREATE or REPLACE FUNCTION wait_until_segments_are_down(num_segs int) RETURNS bool AS $$ declare retries int; /* in func */ begin /* in func */ retries := 40; /* in func */ loop /* in func */ if (select count(*) = num_segs from gp_segment_configuration where status = 'd') then /* in func */ return true; /* in func */ end if; /* in func */ if retries <= 0 then /* in func */ return false; /* in func */ end if; /* in func */ perform pg_sleep(0.1); /* in func */ retries := retries - 1; /* in func */ end loop; /* in func */ end; /* in func */ $$ language plpgsql execute on master;
CREATE

create table fts_mnt_tbl(i integer);
CREATE
insert into fts_mnt_tbl select i from generate_series(1, 100)i;
INSERT 100

-- CASE#1: mirror get's down when fts is in maintenance and is recovered
-- when maintenance is removed

-- no segment down.
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Kill a mirror segment
select pg_ctl((select datadir from gp_segment_configuration c where c.role='m' and c.content=1), 'stop');
 pg_ctl 
--------
 OK     
(1 row)

-- Take a nap to make sure FTS would notice a failed segment
select wait_until_segments_are_down(1);
 wait_until_segments_are_down 
------------------------------
 f                            
(1 row)

-- Still no segmens down
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Even after a manual probe?
select gp_request_fts_probe_scan();
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Try read - non blocking
1:select count(*) from fts_mnt_tbl;
 count 
-------
 100   
(1 row)

-- Try write - blocking
2&:insert into fts_mnt_tbl select i from generate_series(101, 200)i;  <waiting ...>

-- Try recovereseg - noop
!\retcode gprecoverseg -a;
(exited with code 0)

-- Still no segmens down
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Still blocking
3&:insert into fts_mnt_tbl select i from generate_series(201, 300)i;  <waiting ...>

-- Turn maintenance off
!\retcode gpconfig -c gp_fts_maintenance -v off --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 1)

-- writes unblock
2<:  <... completed>
INSERT 100
3<:  <... completed>
INSERT 100

-- gpsegment configuration changes
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 1     
(1 row)

-- gpsecoverseg works
!\retcode gprecoverseg -a;
(exited with code 0)

-- gpsegment configuration changes
select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

1q: ... <quitting>
2q: ... <quitting>
3q: ... <quitting>

-- CASE#2: mirror get's down when fts is in maintenance and is successfully recovered
-- with cluster restart
!\retcode gprecoverseg -ar;
(exited with code 0)
!\retcode gpconfig -c gp_fts_maintenance -v on --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

-- Kill a mirror segment
select pg_ctl((select datadir from gp_segment_configuration c where c.role='m' and c.content=1), 'stop');
 pg_ctl 
--------
 OK     
(1 row)

-- Take a nap to make sure FTS would notice a failed segment
select wait_until_segments_are_down(1);
 wait_until_segments_are_down 
------------------------------
 f                            
(1 row)

-- Lets check that after restart our cluster is working fine
!\retcode gpstop -ra -M fast;
(exited with code 0)

-- both operations should be not blocking
4:select count(*) from fts_mnt_tbl;
 count 
-------
 300   
(1 row)
5:insert into fts_mnt_tbl select i from generate_series(301, 400)i;
INSERT 100

6:show gp_fts_maintenance;
 gp_fts_maintenance 
--------------------
 on                 
(1 row)

-- CASE#3: mirror get's down when fts is in maintenance and is restarted manually

-- Kill a mirror segment
7:select pg_ctl((select datadir from gp_segment_configuration c where c.role='m' and c.content=1), 'stop');
 pg_ctl 
--------
 OK     
(1 row)

-- Take a nap to make sure FTS would notice a failed segment
8:select wait_until_segments_are_down(1);
 wait_until_segments_are_down 
------------------------------
 f                            
(1 row)
9:select gp_request_fts_probe_scan();
 gp_request_fts_probe_scan 
---------------------------
 t                         
(1 row)

-- should block
10&:insert into fts_mnt_tbl select i from generate_series(401, 500)i;  <waiting ...>

-- revive the mirror
11:select pg_ctl_start(datadir, port) from gp_segment_configuration where role = 'm' and content = 1;
 pg_ctl_start     
------------------
 server starting
 
(1 row)

-- should unblock
10<:  <... completed>
INSERT 100

4q: ... <quitting>
5q: ... <quitting>
6q: ... <quitting>
7q: ... <quitting>
8q: ... <quitting>
9q: ... <quitting>
10q: ... <quitting>
11q: ... <quitting>

-- CASE#4: mirror is killed when fts is in maintenance and cannot start. GP stil does not mark it as down
-- in gp_segment_configuration

-- Kill a mirror segment
12:select pg_ctl((select datadir from gp_segment_configuration c where c.role='m' and c.content=1), 'stop');
 pg_ctl 
--------
 OK     
(1 row)

-- Guarantee that it won't start. Surely there is a better way which I didn't find
!\retcode rm -r `psql -Aqt -d postgres -c "select datadir from gp_segment_configuration where role = 'm' and content=1"` 
13:select gp_request_fts_probe_scan();
(exited with code 2)

-- gp segment configuration does not change
14:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Lets check that after restart our maintenance is working fine
!\retcode gpstop -ra -M fast;
(exited with code 2)

-- gp segment configuration still does not change
15:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Try read - non blocking
16:select count(*) from fts_mnt_tbl;
 count 
-------
 500   
(1 row)

-- Try write - blocking
17&:insert into fts_mnt_tbl select i from generate_series(501, 600)i;  <waiting ...>

-- noop
!\retcode gprecoverseg -Fa;
(exited with code 0)

-- Turn maintenance off
!\retcode gpconfig -c gp_fts_maintenance -v off --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 1)

-- should recover
17<:  <... completed>
INSERT 100
-- fts detected the failed segment
19:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 1     
(1 row)
!\retcode gprecoverseg -Fa;
(exited with code 0)

-- all good
20:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

12q: ... <quitting>
13q: FAILED:  Sessions not started cannot be quit
14q: ... <quitting>
15q: ... <quitting>
16q: ... <quitting>
17q: ... <quitting>
19q: ... <quitting>
20q: ... <quitting>

-- CASE#5: primary get's down when fts is in maintenance and reads/writes get errors. gprecoverseg only fixes
-- the problem when fts maintenance is lifted

!\retcode gpconfig -c gp_fts_maintenance -v on --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)

-- no segment down.
21:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Kill a mirror segment
22:select pg_ctl((select datadir from gp_segment_configuration c where c.role='p' and c.content=1), 'stop');
 pg_ctl 
--------
 OK     
(1 row)

-- Take a nap to make sure FTS would notice a failed segment
23:select wait_until_segments_are_down(1);
 wait_until_segments_are_down 
------------------------------
 f                            
(1 row)

-- Still no segmens down
24:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Try read - non blocking, failing
25:select count(*) from fts_mnt_tbl;
ERROR:  failed to acquire resources on one or more segments
DETAIL:  could not connect to server: Connection refused
	Is the server running on host "127.0.1.1" and accepting
	TCP/IP connections on port 6003?
 (seg1 127.0.1.1:6003)

-- Try write - non blocking, failing
26:insert into fts_mnt_tbl select i from generate_series(601, 700)i;
ERROR:  failed to acquire resources on one or more segments
DETAIL:  could not connect to server: Connection refused
	Is the server running on host "127.0.1.1" and accepting
	TCP/IP connections on port 6003?
 (seg1 127.0.1.1:6003)

-- Try recovereseg - noop
!\retcode gprecoverseg -a;
(exited with code 2)

-- Still no segmens down
27:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

-- Still failing
28:select count(*) from fts_mnt_tbl;
ERROR:  failed to acquire resources on one or more segments
DETAIL:  could not connect to server: Connection refused
	Is the server running on host "127.0.1.1" and accepting
	TCP/IP connections on port 6003?
 (seg1 127.0.1.1:6003)

-- Turn maintenance off
!\retcode gpconfig -c gp_fts_maintenance -v off --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 1)

-- gpsegment configuration changes
29:select wait_until_segments_are_down(1);
 wait_until_segments_are_down 
------------------------------
 t                            
(1 row)
30:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 1     
(1 row)

-- gpsecoverseg works
!\retcode gprecoverseg -Fa;
(exited with code 0)
!\retcode gprecoverseg -ra;
(exited with code 0)
31:select count(*) from gp_segment_configuration where status = 'd';
 count 
-------
 0     
(1 row)

32:drop table fts_mnt_tbl;
DROP

!\retcode gpconfig -r gp_fts_probe_retries --masteronly;
(exited with code 0)
!\retcode gpconfig -r gp_fts_probe_interval --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpconfig -r gp_fts_maintenance --skipvalidation --masteronly;
(exited with code 0)
!\retcode gpconfig -r statement_timeout;
(exited with code 0)
!\retcode gpstop -u;
(exited with code 0)
